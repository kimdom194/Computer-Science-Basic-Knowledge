### 프로세스의 개념

- 실행중인 프로그램
- 프로세스의 문맥
  - 타임쉐어링 같은 CPU를 나누어 쓰는것이 중요한 현 시점에서는 다른 작업을 하다가 다시 이어서 작업을 하기 위해서 프로세스 문맥 파악이 중요함.
    - 하드웨어 문맥
      - Program Counter
      - 각종 register
    - 프로세스의 주소 공간
      - code, data, stack
    - 프로세스 관련 커널 자료 구조
      - PCB(Process Control Block)
        - 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보
          - OS가 관리상 사용하는 정보
            - 프로세스 상태, ID값
            - 스케줄링 정보
          - CPU 수행 관련 하드웨어 값
            - PC, 레지스터
          - 메모리 관련
            - Code, Data, Stack의 위치 정보
          - 파일 관련
            - Open file descriptors
      - Kernel stack
        - 유저 프로세스로 복귀할 리턴 주소
        - 유저 프로세스가 커널에 넘기는 매개 변수들



### 프로세스의 상태

- Running
  - CPU를 잡고 instruction을 수행중인 상태
- Ready
  - CPU를 기다리는상태(메모리 등 다른 조건을 모두 만족하고)
  - 최소한의 메모리는 보유
- Blocked(wait, sleep) : 자신이 요청한 event가 만족되면 Ready
  - CPU를 주어도 당장 instruction을 수행할 수 없는 상태
  - Process 자신이 요청한 event(ex : 입출력)가 즉시 만족되지 않아 이를 기다리는 상태

- Suspended(stopped) : 외부에서 재개해 주어야 Active
  - 외부적은 이유로 프로세스의 수행이 정지된 상태
  - 프로세스는 통째로 디스트에 swap out 된다.

- New : 프로세스가 생성중인 상태
- Terminated : execution이 끝난 상태



##### 유저모드와 커널모드

- 커널에서 중요한 자원을 관리하기 때문에, 사용자가 그 중요한 자원에 접근하지 못하도록 모드를 2가지로 나눈 것

- 유저모드

  - 유저가 접근할 수 있는 영역을 제한적으로 두고, 프로그램 자원에 함부로 침범하지 못하는 모드
  - 코드를 작성하고, 프로세스를 실행하는 등의 행동을 할 수 있다.

- 커널모드

  - 모든 자원(드라이버 메모리, CPU 등)에 접근, 명령을 할 수 있다.
  - 유저모드와는 비교가 안되게 컴퓨터 내부의 모든 것을 할 수 있다.

  

### 문맥 교환

- CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
- CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행
  - CPU를 내어주는 프로세스의 상태(레지스터, PC, 메모리 맵)를 그 프로세스의 PCB에 저장
  - CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴
- 문맥 교환은 다른 프로세스로 넘어갈때 발생함.
  - 프로세스 A > 시스템 콜, interrupt  > 프로세스 A(문맥 교환 아님)
  - 프로세스 A > Timer interrupt or I/O 요청 System call > 프로세스 B(문맥 교환 발생)



### 프로세스를 스케줄링하기 위한 큐

- Job queue
  - 현재 시스템 내에 있는 모든 프로세스의 집합
- Ready queue
  - 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
- Device queues
  - I/O 디바이스의 처리를 기다리는 프로세스의 집합



### 스케줄러

- Long-term scheduler(장기 스케줄러 or job 스케줄러)
  - 시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정
  - 프로세스에 memory를 주는 문제
  - degree of Multiprogramming(수행중인 프로세스의 수)을 제어
  - time sharing system(요즘 시스템)에는 보통 장기 스케줄러가 없음(무조건 ready)
- short-term(단기 스케줄러 or CPU 스케줄러)
  - 어떤 프로세스를 다음에 running시킬지 결정
  - 프로세스에 CPU를 주는 문제
  - 충분히 빨라야함(millisecond 단위)
- Medium-term(중기 스케줄러 or Swapper)
  - 여유 공간을 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫒아냄
  - 프로세스에게서 memory를 뺏는 문제
  - degree of Multiprogramming(수행중인 프로세스의 수)을 제어



### 동기식 입출력과 비동기식 입출력

- 동기식 입출력
  - 입출력 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
    - I/O가 끝날 때까지 CPU를 낭비시킴
    - 매시점 하나의 I/O만 일어남
- 비동기식 입출력
  - 입출력이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 넘어감



### Thread

- CPU를 수행하는 단위
- 구성
  - PC
  - 레지스터
  - 스택
- 다른 스레드와 공유하는 부분(=Task)
  - 코드
  - 데이터
  - OS 자원
- 장점
  - 하나의 스레드가 blocked 상태인 경우 다른 스레드가 수행될 수 있다.
  - 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율과 성능의 향상
  - 병령성을 높일 수 있다.
  - 보호영역을 갖고 있지 않다는 장점
    - 보호영역이란?
      - 시스템의 동작 및 관리에 중요한 역할을 담당하는 정보가 저장되어있는 기억장소 영역
      - 즉 프로세스는 자신의 보호영역을 가지고 있어서 프로세스간의 의사소통시스템이 필요하지만, 스레드간의 보호영역이 없고 공유하기 때문에 변수의 변경 이후 별도의 커뮤니케이션이 필요하지 않다.