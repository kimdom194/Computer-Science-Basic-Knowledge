### CPU의 기능

- 명령어 인출 : 기억장치로부터 명령어를 읽어온다.

- 명령어 해독 : 수행해야 할 동작을 결정햐기 위하여 명령어를 해독한다.

  ####  모든 명령에서 공통적으로 수행한다.

- 데이터 인출 : 기억장치 혹은 I/O장치로부터 데이터를 읽어온다.

- 데이터 처리 : 데이터에 대한 산술적, 논리적 연산을 수행

- 데이터 쓰기 : 수행 결과 저장

  #### 명령어에 따라 필요한 경우에만 수행

  

### CPU의 구조

 - 산술논리연산장치(ALU)
    - 각종 산술 연산들과 논리 연산들을 수행하는 회로로 이루어진 하드웨어
   - 산술 연산 : 덧셈, 뺄셈, 곱하기, 나누기
   - 논리 연산 : AND, OR, NOT, XOR
 - 레지스터 세트
    - 액세스 속도가 가장 빠른 기억장치
    - CPU 내부에 포함할 수 있는 레지스터들의 수가 제한됨
 - 제어 유니트
    - 프로그램 코드를 해석하고 실행하기 위한 제어 신호들을 순차적으로 발생하는 하드웨어 모듈
- CPU 내부 버스
  - ALU와 레지스터들 간의 데이터 이동을 위한 데이터 선들과 제어 유니트로부터 발생되는 제어 신호 선들로 구성된 내부 버스
  - 외부의 시스템 버스들과는 직접 연결되지 않으며, 반드시 버퍼 레지스터들 혹은 시스템 버스 인터페이스 회로를 통하여 시스템 버스와 접속



### 명령어 실행

- 명령어 사이클

  - CPU가 한 개의 명령어를 실행하는데 필요한 전체 처리과정

  - 부사이클

    - 인출 사이클 : CPU가 기억장치로 명령을 읽어오는 단계

      - 인출 사이클의 마이크로 연산

        1. MAR < PC : 현재 PC 내용을 CPU 내부 버스를 통하여 MAR로 전송
        2. MBR < M[MAR], PC < PC + 1 : 그 주소(M)가 지정하는 기억장치 위치로부터 읽혀진 명령어가 데이터 버스를 통하여 MBR로 적재되며, PC의 내용에 1(기본 단위)을 더한다.
        3. IR < MBR : MBR에 있는 명령어 코드가 명령어 레지스터인 IR로 이동

        - EX) CPU 클럭 = 1GHz(클럭 주기 = 1ns)

          > 인출 사이클 : 1ns * 3 = 3ns 소요

    - 실행 사이클 : 명령어를 실행하는 단계이다. CPU는 실행 사이클 동안에 명령어 코드를 해독하고, 그 결과에 따라 필요한 연산들을 수행한다.

      - CPU가 수행하는 연산의 종류 : 데이터 이동, 처리, 저장, 제어

- 명령어 실행에 필요한 CPU 내부 레지스터들

  - 프로그램 카운터(PC)

    - 다음에 인출할 명령어의 주소를 가지고 있는 레지스터
    - 각 명령어가 인출된 후에는 자동적으로 일정 크기(한  명령어 길이)만큼 증가
    - 분기 명령어가 실행되는 경우에는 목적지 주소로 갱신

  - 누산기(AC)

    - 데이터를 일시적으로 저장하는 레지스터
    - 레지스터 크기는 CPU가 한 번에 처리할 수 있는 데이터 비트수

  - 명령어 레지스터(IR)

    - 가장 최근에 인출된 명령어 코드가 저장되어 있는 레지스터

  - 기억장치 주소 레지스터(MAR)

    - PC에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 주소 레지스터

  - 기억장치 버퍼 레지스터(MBR)

    - 기억장치에 쓰여질 데이터 혹은 기억장치로부터 읽혀진 데이터를 일시적으로 저장하는 버퍼 레지스터

    

###  기본적인 명령어의 형식

- 연산코드
  - CPU가 수행할 연산을 지정
- 오퍼랜드
  - 명령어 실행에 필요한 데이터가 저장된 주소(addr)
- LOAD addr : 기억장치에 저장되어 있는 데이터를 CPU 내부 레지스터인 AC로 이동하는 명령어
  1. MAR < IR(addr) : 명령어 레지스터 IR에 있는 명렁어의 주소 부분(오퍼랜드)을 MAR로 전송
  2. MBR < M[MAR] : 그 주소가 지정한 기억장소로부터 데이터를 인출하여 MBR로 전송
  3. AC < MBR : 그 데이터를 AC에 적재
- STA addr : AC 레지스터의 내용을 기억장치에 저장하는 명령어
  1. MAR < IR(addr) : 데이터를 저장할 기억장치의 주소를 MAR로 전송
  2. MBR < AC : 저장할 데이터를 버퍼 레지스터인 MBR로 이동
  3. M[MAR] < MBR :  MBR의 내용을 MAR이 지정하는 기억장소에 저장
- ADD addr : 기억장치에 저장된 데이터를 AC의 내용과 더하고, 그 결과는 다시 AC에 저장하는 명령어
  1. MAR < IR(addr) : 데이터를 저장할 기억장치의 주소를 MAR로 전송
  2. MBR < M[MAR] : 저장할 데이터를 버퍼 레지스터인 MBR로 이동
  3. AC < AC + MBR : 그 데이터와 AC의 내용을 더하고 결과겂을 다시 AC에 저장
-  JUMP addr : 오퍼렌드가 가리키는 위치의 명령어로 실행 순서를 변경하는 분기 명령어
  1. PC < IR(addr) : 명령어의 오퍼랜드가 PC에 저장
     - 다음 명령어 인출 사이클에서 그 주소의 명령어가 인출되므로 분기가 발생



### 인터럽트 사이클

 - 인터럽트 : 프로그램 실행 중에 CPU의  현재 처리 순서를 중단시키고 다른 동작을 수행하도록 하는 시스템 동작

 - 외부로부터 인터럽트 요구가 들어오면, CPU는 원래의 프로그램 수행을 중단하고 요구된 인터럽트를 위한 서비스 프로그램을 먼저 수행

 - ##### 인터럽트 서비스 루틴 : 인터럽트를 처리하기 위하여 수행하는 프로그램 루틴

 - #### 인터럽트 처리 과정

   - 인터럽트가 들어왔을 때 CPU
      - 어떤 장치가 인터럽트를 요구했는지 확인하고, 해당 ISR(서비스루틴)을 호출
      - 서비스가 종료된 다음에는 중단되었던 원래 프로그램의 수행 진행
   - CPU 인터럽트 처리의 세부 동작
     1. 현재의 명령어 실행을 끝낸 즉시, 다음에 실행할 명령어의 주소(PC의 내용)를 스택에 저장 > 일반적으로 스택은 주기억장치의 특정 부분
     2. ISR을 호출하기 위하여 그 루틴의 시작 주소를 PC에 적재, 이때 시작 주소는 인터럽트를 요구한 장치로부터 전송되거나 미리 정해진 값으로 결정
   - 인터럽트 사이클의 마이크로 연산
     1. MBR < PC : PC의 내용이 MBR로 전송
     2. MAR < SP, PC < ISR의 시작주소 : SP의 내용이 MAR로 전송되고, PC의 내용은 인터럽트 서비스 루틴의 시작주소로 변경
     3. M[MAR] < MBR, SP < SP -1 : MBR에 저장되어 있던 원래 PC의 내용이 스택에 저장

     

### 다중 인터럽트

 - 인터럽트 서비스 루틴을 수행하는 동안에 다른 인터럽트 발생

 - #### 다중 인터럽트의  처리방법

    - CPU가 인터럽트 서비스 루틴을 처리하고 있는 도중에는 새로운 인터럽트 요구가 들어오더라도 인터럽트 사이클을 수행하지 않도록 방지
    - 인터럽트 플래그 = 인터럽트 불가능

   

### 간접 사이클 (C Pointer)

 - 명령어에 포함되어 있는 주소를 이용하여, 그 명령어 실행에 필요한 데이터의 주소를 인출하는 사이클 > 간접 주조지정 방식에서 사용

 - 인출 사이클과 실행 사이클 사이에 위치

 - 간접 사이클에서 수행될 마이크로 연산

   1. MAR < IR(addr)
   2. MBR < M[MAR]
   3. IR[addr] < MBR

   인출된 명령어의 주소 필드 내용을 이용하여 기억장치로부터 데이터의 실제 주소를 인출하여 IR의 주소 필드에 저장



### 명령어 파이프라이닝

 - CPU의 프로그램 처리 속도를 높이기 위하여 CPU 내부 하드웨어를 여러 단계로 나누어 동시에 처리하는 기술

   - 2단계 명령어 파이프라인
      - 명령어를 실행하는 하드웨어를 인출단계와 실행단계라는 두 개의 독립적인 파이프라인 모듈로 분리
      - 두 단계들에 동일한 클록을 가하여 동작시간을 일치
      - 명령어 처리 속도가 2배 향상
      - 문제점 : 두 단계의 처리 시간이 동일하지 않으면 두 배의 속도 향상을 얻지못함
   - 4단계 명령어 파이프라인
     1. 명령어 인출
     2. 명령어 해독
     3. 오퍼랜드 인출
     4. 실행

   파이프라인에 의한 전체 명령어 실행 시간

   

### 해저드 : Hazard

- 중앙처리장치의 마이크로 구조의 명령어 파이프라인에서 발생하는 문제로서 잠재적으로 계산의 결과에 오류가 발생하는 것

- 3가지 종류의 해저드

  1. 데이터 해저드

     - 파이프라인의 서로 다른 단계에서 수정이 필요한 데이터들 끼리 의존성이 존재할 때 발생한다. 잠재적인 데이터 해저드를 무시하게 되면 경쟁조건(데이터를 주고받지 않는)이 발생할 수 있다.

     - 데이터 해저드의 3가지 상황

       1. read after write(RAW) : 참 의존성

          - 참 종속성을 가지므로 원천적으로 해결하지 못함
          - 파이프라인에 버블을 끼워 넣는 방법을 사용
          - 명령어 재배치

          - i1이 어떤 값을 저장하기 전에 i2가 그 값을 읽으려고한다.

       2. WAR, WAW : 레지스터 이름을 바꾸어줌, 하드웨어적인 방법이나 컴파일러가 바꿔줌, 여분의 레지스터가 있어야함

          - write after read(WAR)
            - i1이 읽어가기 전에 i2가 목적지에 저장하려고 하는 경우
          - write after write(WAW)
            - i1이 저장하기 이전에 i2가 저장하려고 하는 경우

  2. 구조적 해저드

     - 동시에 두개 이상의 명령이 프로세서의 하드웨어 중 한 부분을 사용하려고 할 때 발생한다.
        	1. 명령어 인출과 데이터 인출이 동시에 발생
            - 메모리 장치를 분리하거나 분리 캐시를 사용하는 방법
            - 메모리 자체를 분리하는 경우 : 하버드 아키텍쳐
            - 파이프라인에 버블을 끼워 넣는 방법
           	2. CPU 내의 장치에서 충돌이 생기는 경우
            - 추가적으로 장치를 여러개 둠(ALUF를 2~3개 둠)

  3. 제어 해저드 또는 분기 해저드

     - 분기가 발생할 때 일어난다. 많은 명령 파이프라인 마이크로구조에서 프로세서는 파이프라인에 새로운 명령이 들어갈 때(일반적으로 명령 인출단계에서) 분기가 발생할지를 알 필요가 있지만 실제로는 분기의 결과를 알 수 없다.

     - #### 분기 발생에 의한 성능 저하의 최소화 방법

       - 분기 예측 
       - 분기 목적지 선인출
       - 루프버퍼 사용
       - 지연 분기

- 해저드를 피하는 방법 : 파이프라인 스톨(속도를 낮춘다), 버블링(거품을 넣는다), 레지스터 포워딩

  


### 상태 레지스터

 - 조건분기 명령어가 사용할 조건 플래그들 저장

1. 부호(S) 플래그

2. 영 플래그(Z)

3. 올림수 플래그(C)

4. 동등 플래그

5. 오버플로우

6. 인터럽트 플래그

   

### 슈퍼스칼라

- CPU의 처리 속도를 더욱 높이기 위하여 내부에 2개 혹은 그 이상의 명령어 파이프라인들을 포함시킨 구조
- 매 클럭 주기마다 각 명령어 파이프라인이 별도의 명령어를 인출하여 동시에 실행할 수 있기 때문에, 이론적으로는 처리속도가 파이프라인의 수 만큼 향상 가능
- 슈퍼스칼라의 속도 저하 요인 : 동시 실행 가능한 명령어 수 < 파이프라인 수
- 해결책
  - 명령어 실행 순서 재배치 : 명령어들 간의 데이터 의존성 제거
  - 하드웨어 추가 설치 : 기억장치 및 레지스터에 대한 경합 감소

    

### 듀얼 코어 및 멀티 코어

- CPU 코어 : 명령어 실행에 필요한 CPU 내부의 핵심 하드웨어(슈퍼스칼라 모듈)
- 멀티 코어 프로세서 : 여러 개의 CPU코어들을 하나의 칩에 포함시킨 프로세서
  - 각 코어는 별도의 HW 모듈로 이루어지며, 시스템 버스와 캐시만 공유(프로그램 실행에 있어서 각 코어는 슈퍼스칼라의 각 파이프라인보다 더 높은 독립성을 가짐 > 멀티 태스킹, 멀티 스레딩)

    

### 명령어 세트

- 어떤 CPU를 위하여 정의되어 있는 명령어들의 집합

- 명령어 세트 설계를 위해 결정되어야 할 사항들

  - 연산 종류

    - 데이터 전송

    - 산술연산

    - 논리연산

    - 입출력

    - 프로그램 제어

      - 서브루틴 호출을 위한 명령어들

        - CALL 명령어 : PC 내용을 스택에 저장하고 서브루틴의 시작주소로 분기

        - CALL 명령어 마이크로 연산

          1. MBR < PC
          2. MAR < SP, PC < X
          3. M[MAR]< MBR, SP < SP - 1

          - 현재의 PC 내용(서브루틴 수행 완료 후에 복귀할 주소)을 SP가 지정하는 스택의 최상위에 저장
          - 만약 주소 지정 단위가 바이트이고 저장될 주소는 16비트라면, SP < SP - 2로 변경

        - RET 명령어 : CPU가 원래 실행하던 프로그램으로 복귀

        - RET 명령어의 마이크로 연산

          1. SP < SP + 1
          2. MAR < SP
          3. PC < M[MAR]

  - 데이터 형태

  - 명령어 형식

  - 주소지장 방식

    

### 명령어 형식

- 명령어의 구성요소들

  - 연산코드 : 수행될 연산을 지정(LOAD, ADD)
  - 오퍼랜드
    - 연산을 수행하는 데 필요한 데이터 혹은 데이터의 주소
    - 각 연산은 한 개 혹은 두 개의 입력 오퍼랜드들과 한개의 결과 오퍼랜드를 포함
    - 데이터는 CPU 레지스터, 주기억장치, 혹은 I/O 장치에 위치
  - 다음 명령어 주소
    - 현재의 명령어 실행이 완료돤 후에 다음 명령어를 인출할 위치 지정
    - 분기 혹은 호출 명령어와 같이 실행 순서를 변경하는 경우에 필요

  - 필드 : 명령어의 각 구성 요소들에 시요되는 비트들의 그룹
  - 명령어 형식 : 명령어 내 필드들의 수와 배치 방식 및 각 필드들의 비트 수
  - 명령어의 길이 = 단어 길이

- 명령어 형식의 결정에서 고려할 사항
  - 연산 코드 필드 길이 : 연산의 개수를 결정
  - 4비트 > 2의 4승 16가지의 연산 정의 가능
  - 만약 연산코드 길이가 늘어난다면 다른 필드의 길이가 감소
- 오퍼랜드 필드의 길이 : 오퍼랜드 범위 결정
  - 오퍼랜드의 종류에 따라 범위가 달라짐
    - 데이터 : 표현 가능한 수의 크기가 결정
    - 기억장치 주소 : 기억장치 영역의 범위가 결정
    - 레지스터 번호 : 레지스터의 수가 결정
- 오퍼랜드 수에 따른 명령어 분류
  - 1 주소 명령어 : 오퍼랜드를 한 개만 포함하는 명령어
    - ADD X AC	AC + M[X]
  - 2 주소 명령어 : 두개의 오퍼랜드를 포함하는 명령어
    - ADD R1, R2	R1 < R1 + R2
    - MOV R1, R2
    - ADD R1, X
  - 3 주소 명령어 : 세개의 오퍼랜드를 포함하는 명령어
    - ADD R1, R2,  R3	R1 < R1 + R3



### 주소 지정 방식

 - 다양한 주소지정 방식을 사용하는 이유 : 제한된 수의 명령어 비트들을 이용하여 사용자로 하여금 여러가지 방법으로 오퍼랜드를 지정하고 더 큰 용량의 기억장치를 사용할 수 있도록 하기 위해
 - 기호
   - EA : 유효 주소, 데이터가 저장된 실제 주소
   - A : 명령어 내의 주소 필드 내용
   - R : 명령어 내의 레지스터 번호
   - (A) : 기억장치 A 번지의 내용
   - (R) : 레지스터 R의 내용
- 직접 주소지정 방식
  - 오퍼랜드 필드의 내용이 유효 주소가 되는 방식
    - EA = A
  - 장점 : 데이터 인출을 위하여 한번의 기억장치 액세스만 필요
  - 단점 : 연산 코드를 제외하고 남은 비트들만 주소 비트로 사용될 수 있기 때문에 직접 지정할 수 있는 기억장소의 수가 제한
- 간접 주소지정 방식
  - 주소가 가리키는 기억장소에 데이터의 유효 주소가 저장되어 있도록 하는 방식
  - 장점 : 최대 기억장치용량이 단어의 길이에 의해 결정 > 확장 가능
  - 단점 : 실행 사이클 동안에 두번의 기억장치 액세스가 필요
- 묵시적 주소지정 방식
  - 데이터 위치가 묵시적으로 지정되는 방식
    - SHL 명령어 : 누산기 내용을 좌측으로 쉬프트
    - PUSH R1 명령어 : 레지스터 R1의 내용을 스택에 저장
  - 장점 : 명령어 길이가 짧다.
  - 단점 : 종류가 제한된다.

- 즉치 주소지정 방식
  - 데이터가 명령어에 포함되어 있는 방식
  - 용도 : 레지스터들이나 변수의 초기 값을 어떤 상수값으로 세트하는데 유용하게 사용
  - 장점 : 데이터를 인출하기 위하여 기억장치를 액세스할 필요가 없음
  - 단점 : 상슈값의 크기가 오퍼랜드 필드의 비트 수에 의하여 제한

- 레지스터 주소지정 방식

  - 연산에 사용될 데이터가 레지스터에 있는 방식 **EA = R**
  - 주소지정에 사용될 수 있는 레지스터들의 수 = 2의 k승
  - 장점 : 필드의 비트수가 적어도 된다. 기억장치 액세스가 필요 없다.
  - 단점 : 데이터가 저장될 수 있는 공간이 CPU 내부 레지스터들로 제한

- 레지스터 간접 주소지정 방식

  - 오퍼랜드 필드가 가리키는 레지스터의 내용을 유효 주소로 사용하여 실제 데이터를 인출하는 방식 **EA = (R)**
  - 장점 : 주소지정 할 수 있는 기억장치 영역이 확장

- 변위 주소지정 방식

  - 직접 주소지정과 레지스터 간접주소 지정 방식의 조합
  - 사용되는 레지스터에 따라 여러 종류의 변위 주소지정 방식의 정의
    - PC > 상대 주소지정 방식
    - 인덱스 레지스터 > 인덱스 주소지정 방식
    - 베이스 레지스터 > 베이스 레지스터 주소지정 방식

- 상대 주소지정 방식

  - 프로그램 카운터(PC)를 레지스터로 사용(주로 분기 명령에서 사용) **EA = A + (PC)** 단 A는 2의 보수
    - A 는 0보다 크거나 같다 : 앞 방향으로 분기
    - A 는 0보다 작다 : 뒷 방향으로 분기
  - 장점 : 일반적인 분기 명령어보다 적은 수의 비트만 있으면 된다
  - 단점 : 분기 범위가 오퍼랜드 필드의 길이에 의하여 제한

- 인덱스 주소지정 방식

  - 인덱스 레지스터의 내용과 변위 A를 더하여 유효 주소 결정

  - **EA = (IX) + A ** IX : 인덱스 값을 저장하는 특수 레지스터

  - 주요 용도 : 배열 데이터 액세스

  - #### 자동 인덱싱

    - 명령어가 실행될 때마다 인덱스 레지스터의 내용이 자동적으로 증가 혹은 감소
    - 이 방식이 사용된 명령어가 실행되면 아래의 두 연산이 연속적으로 수행됨
      - EA = (IX) + A
      - IX < IX + 1

- 베이스 레지스터 주소지정 방식

  - 베이스 레지스터의 내용과 변위 A를 더하여 요호 주소를 결정

    ​	**EA = (BR) + A**

  - 주요 용도 : 서로 다른 세그먼트내 프로그램의 위치 지정 

    

### 실제 상용 프로세서들의 명령어 형식

 - PDP-10 프로세서 : 고정 길이의 명령어 형식 사용

    - 단어의 길이 = 36비트 명령어의 길이 = 36비트
    - 연산코드 = 9비트 > 최대 512 종류의 연산 허용

 - PDP-11프로세서 : 다양한 길이의 명령어 형식들 사용

    - 연산 코드 = 4 ~ 16 비트
    - 주소 개수 : 0, 1, 2개

- #### 펜티엄 프로세서의 명령어 형식

  - 선형주소 : 유효주소 + 세그먼트의 시작 주소(세그먼트의 시작 주소는 세그먼트 레지스터에 저장)

# 파이프라인이랑 데이터 해저드 다시 공부하기 (가장 중요한 부분)